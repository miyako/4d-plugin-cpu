/* --------------------------------------------------------------------------------
 #
 #	4DPlugin.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : CPU
 #	author : miyako
 #	2017/06/19
 #
 # --------------------------------------------------------------------------------*/


#include "4DPluginAPI.h"
#include "4DPlugin.h"

void PluginMain(PA_long32 selector, PA_PluginParameters params)
{
	try
	{
		PA_long32 pProcNum = selector;
		sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
		PackagePtr pParams = (PackagePtr)params->fParameters;

		CommandDispatcher(pProcNum, pResult, pParams); 
	}
	catch(...)
	{

	}
}

void CommandDispatcher (PA_long32 pProcNum, sLONG_PTR *pResult, PackagePtr pParams)
{
	switch(pProcNum)
	{
// --- CPU

		case 1 :
			CPU_Get_count(pResult, pParams);
			break;

	}
}

// -------------------------------------- CPU -------------------------------------

#if VERSIONMAC
#include <sys/sysctl.h>
#else
// Helper function to count set bits in the processor mask.
DWORD CountSetBits(ULONG_PTR bitMask)
{
	DWORD LSHIFT = sizeof(ULONG_PTR) * 8 - 1;
	DWORD bitSetCount = 0;
	ULONG_PTR bitTest = (ULONG_PTR)1 << LSHIFT;
	DWORD i;

	for (i = 0; i <= LSHIFT; ++i)
	{
		bitSetCount += ((bitMask & bitTest) ? 1 : 0);
		bitTest /= 2;
	}

	return bitSetCount;
}
#endif

#define Number_of_processor_cores 0
#define Number_of_logical_processors 1

void CPU_Get_count(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_LONGINT Param1;
	C_LONGINT returnValue;

	Param1.fromParamAtIndex(pParams, 1);

#if VERSIONWIN
	std::vector<SYSTEM_LOGICAL_PROCESSOR_INFORMATION> slpi;
	DWORD dwSize = 0;
	DWORD byteOffset = 0;
	DWORD numaNodeCount = 0;
	DWORD processorCoreCount = 0;
	DWORD logicalProcessorCount = 0;
	DWORD processorL1CacheCount = 0;
	DWORD processorL2CacheCount = 0;
	DWORD processorL3CacheCount = 0;
	DWORD processorPackageCount = 0;
	PCACHE_DESCRIPTOR Cache;

	if (!GetLogicalProcessorInformation(slpi.data(), &dwSize))
	{
		slpi.resize(dwSize / sizeof(SYSTEM_LOGICAL_PROCESSOR_INFORMATION));
		
		if (GetLogicalProcessorInformation(slpi.data(), &dwSize))
		{
		
			PSYSTEM_LOGICAL_PROCESSOR_INFORMATION ptr = slpi.data();

			while (byteOffset + sizeof(SYSTEM_LOGICAL_PROCESSOR_INFORMATION) <= dwSize)
			{
				switch (ptr->Relationship)
				{
					case RelationNumaNode:
						// Non-NUMA systems report a single record of this type.
						numaNodeCount++;
						break;
						
					case RelationProcessorCore:
						processorCoreCount++;
						
						// A hyperthreaded core supplies more than one logical processor.
						logicalProcessorCount += CountSetBits(ptr->ProcessorMask);
						break;
						
					case RelationCache:
						// Cache data is in ptr->Cache, one CACHE_DESCRIPTOR structure for each cache.
						Cache = &ptr->Cache;
						if (Cache->Level == 1)
						{
							processorL1CacheCount++;
						}
						else if (Cache->Level == 2)
						{
							processorL2CacheCount++;
						}
						else if (Cache->Level == 3)
						{
							processorL3CacheCount++;
						}
						break;
						
					case RelationProcessorPackage:
						// Logical processors share a physical package.
						processorPackageCount++;
						break;
						
					default:
						break;
				}
				byteOffset += sizeof(SYSTEM_LOGICAL_PROCESSOR_INFORMATION);
				ptr++;
			}
			
		}
	}

	switch (Param1.getIntValue())
	{
	case Number_of_logical_processors:
		returnValue.setIntValue(logicalProcessorCount);
		break;

	default://Number_of_processor_cores
		returnValue.setIntValue(processorCoreCount);
		break;
	}

#else
	
	size_t len;
	unsigned int ncpu;
	len = sizeof(ncpu);

	switch (Param1.getIntValue())
	{
  case Number_of_logical_processors:
				sysctlbyname ("hw.ncpu", &ncpu, &len, NULL, 0);
			break;
			
  default://Number_of_processor_cores
				sysctlbyname ("hw.physicalcpu", &ncpu, &len, NULL, 0);
			break;
	}
	
	returnValue.setIntValue(ncpu);
	
#endif
	returnValue.setReturn(pResult);
}

